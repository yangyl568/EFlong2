import{_ as s,c as a,a as e,o as p}from"./app-eC44gSCD.js";const t={};function o(l,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="vue-项目性能优化-最强" tabindex="-1"><a class="header-anchor" href="#vue-项目性能优化-最强"><span>vue 项目性能优化(最强)</span></a></h1><blockquote><p>原创自：https://juejin.im/post/5d548b83f265da03ab42471d</p></blockquote><h2 id="一、代码层面的优化" tabindex="-1"><a class="header-anchor" href="#一、代码层面的优化"><span>一、代码层面的优化</span></a></h2><blockquote><p>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</p></blockquote><p>方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><blockquote><p>长列表性能优化</p></blockquote><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">this</span><span class="token punctuation">.</span>users <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>事件的销毁</p></blockquote><p>如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token function">beforeDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>click<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>图片资源懒加载</p></blockquote><p>使用 Vue 的 vue-lazyload 插件：对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">（<span class="token number">1</span>）安装插件</span>
<span class="line"></span>
<span class="line">npm install vue<span class="token operator">-</span>lazyload <span class="token operator">--</span>save<span class="token operator">-</span>dev</span>
<span class="line">（<span class="token number">2</span>）在入口文件 man<span class="token punctuation">.</span>js 中引入并使用</span>
<span class="line"></span>
<span class="line"><span class="token keyword">import</span> VueLazyload <span class="token keyword">from</span> <span class="token string">&#39;vue-lazyload&#39;</span></span>
<span class="line">然后再 vue 中直接使用</span>
<span class="line"></span>
<span class="line">Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">)</span></span>
<span class="line">或者添加自定义选项</span>
<span class="line"></span>
<span class="line">Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueLazyload<span class="token punctuation">,</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token literal-property property">preLoad</span><span class="token operator">:</span> <span class="token number">1.3</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token literal-property property">error</span><span class="token operator">:</span> <span class="token string">&#39;dist/error.png&#39;</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token literal-property property">loading</span><span class="token operator">:</span> <span class="token string">&#39;dist/loading.gif&#39;</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token literal-property property">attempt</span><span class="token operator">:</span> <span class="token number">1</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">（<span class="token number">3</span>）在 vue 文件中将 img 标签的 src 属性直接改为 v<span class="token operator">-</span>lazy ，从而将图片显示方式更改为懒加载显示：</span>
<span class="line"></span>
<span class="line"><span class="token operator">&lt;</span>img v<span class="token operator">-</span>lazy<span class="token operator">=</span><span class="token string">&quot;/static/img/1.png&quot;</span><span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>路由懒加载</p></blockquote><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">const</span> <span class="token function-variable function">Com</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;./Com.vue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&quot;/foo&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> Foo <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>第三方 插件的按需引入</p></blockquote><p>具体怎么做，需要查找下文档</p><blockquote><p>优化无限列表性能 （这个需要再研究）</p></blockquote><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 <code>vue-virtual-scroll-list</code> 和 <code>vue-virtual-scroller</code> 来优化这种无限列表的场景的。</p><h2 id="二、webpack-层面的优化" tabindex="-1"><a class="header-anchor" href="#二、webpack-层面的优化"><span>二、Webpack 层面的优化</span></a></h2><blockquote><p>优化 resolve.extensions 配置</p></blockquote><p><strong>问题描述：</strong> 当遇到 require ( &#39;. /data ’）这样的导入语句时，Webpack 会先去寻找./data .js 文件，如果该文件不存在，就去寻找./data.json 文件，如果还是找不到就报错。</p><p><strong>解决方案：</strong> 在源码中写导入语句时，要尽可能带上后缀，从而可以避免寻找过程。例如在确定的情况下将 require(’. /data ’)写成 require(’. /data.json ’)</p><blockquote><p>Webpack 对图片进行压缩 ( <strong>现在使用 tinyPNG 手动压缩也很方便</strong> )</p></blockquote><p>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader 来压缩图片： <a href="https://github.com/tcoopman/image-webpack-loader" target="_blank" rel="noopener noreferrer">查看详细使用</a></p><blockquote><p>减少 ES6 转为 ES5 的冗余代码(这个有点意思)</p></blockquote><p>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码： <code>class HelloWebpack extends Component{...}</code> 这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">babel <span class="token operator">-</span> runtime <span class="token operator">/</span> helpers <span class="token operator">/</span> createClass<span class="token punctuation">;</span> <span class="token comment">// 用于实现 class 语法</span></span>
<span class="line">babel <span class="token operator">-</span> runtime <span class="token operator">/</span> helpers <span class="token operator">/</span> inherits<span class="token punctuation">;</span> <span class="token comment">// 用于实现 extends 语法</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(&#39;babel-runtime/helpers/createClass&#39;) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">（<span class="token number">1</span>）首先，安装 babel<span class="token operator">-</span>plugin<span class="token operator">-</span>transform<span class="token operator">-</span>runtime ：</span>
<span class="line">npm install babel<span class="token operator">-</span>plugin<span class="token operator">-</span>transform<span class="token operator">-</span>runtime <span class="token operator">--</span>save<span class="token operator">-</span>dev</span>
<span class="line"></span>
<span class="line">（<span class="token number">2</span>）然后，修改 <span class="token punctuation">.</span>babelrc 配置文件为：</span>
<span class="line"><span class="token string-property property">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span></span>
<span class="line">    <span class="token string">&quot;transform-runtime&quot;</span></span>
<span class="line"><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>优化 SourceMap</p></blockquote><p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel 编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug 的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。</p><p><strong>开发环境推荐： cheap-module-eval-source-map 生产环境推荐： cheap-module-source-map</strong></p><blockquote><p>构建结果输出分析 (cli3.0 之后自带)</p></blockquote><p>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。 Vue 项目中用到的分析工具：<code>webpack-bundle-analyzer</code><strong>cli3.0 之后自带</strong> 我们在项目中 <code>webpack.prod.conf.js</code> 进行配置：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>build<span class="token punctuation">.</span>bundleAnalyzerReport<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> BundleAnalyzerPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;webpack-bundle-analyzer&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span>BundleAnalyzerPlugin<span class="token punctuation">;</span></span>
<span class="line">  webpackConfig<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BundleAnalyzerPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行 <code>$ npm run build --report</code> 后生成分析报告如下：</p><h2 id="三、基础的-web-技术优化" tabindex="-1"><a class="header-anchor" href="#三、基础的-web-技术优化"><span>三、基础的 Web 技术优化</span></a></h2><blockquote><p>开启 gzip 压缩</p></blockquote><p>gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右</p><p>观察网络面板里面的 <code>Response Header , Content-Encoding: gzip</code></p><blockquote><p>浏览器缓存 使用 CDN</p></blockquote><p>CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且 CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p><blockquote><p>使用 Chrome Performance 查找性能瓶颈</p></blockquote><p>Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。</p><ol><li>打开 Chrome 开发者工具，切换到 Performance 面板</li><li>点击 Record 开始录制</li><li>刷新页面或展开某个节点</li><li>点击 Stop 停止录制</li></ol><h2 id="如何减少白屏时间" tabindex="-1"><a class="header-anchor" href="#如何减少白屏时间"><span>如何减少白屏时间</span></a></h2><p>主要是因为首次加载资源太多、太大请求慢导致的，所以从这几点入手解决。</p><p>1、因为 解析HTML 时遇到 script 会阻塞 DOM 的构建，所以 后置或者 异步 defer：异步加载，按照顺序执行， async 异步不按照顺序执行</p><p>2、静态资源可以使用 cdn</p><p>3、路由懒加载 import(&#39;....&#39;)</p><p>4、DNS 缓存、预加载策略 preload: 预先加载资源 prefetch：预判加载资源</p>`,54)]))}const i=s(t,[["render",o]]),r=JSON.parse('{"path":"/article/prkb43xt/","title":"vueyouhua","lang":"zh-CN","frontmatter":{"title":"vueyouhua","createTime":"2025/04/24 17:43:17","permalink":"/article/prkb43xt/"},"git":{"updatedTime":1745915104000,"contributors":[{"name":"yuquan","username":"yuquan","email":"yuquan@webuy.ai","commits":2,"url":"https://github.com/yuquan"}],"changelog":[{"hash":"8d7fe1ee1f5bc4f8706cdec86253a368b50ddecb","time":1745915104000,"email":"yuquan@webuy.ai","author":"yuquan","message":"Refactor code structure for improved readability and maintainability"},{"hash":"2c2de146089234711283a4a64d33e9be5c38d4d3","time":1745488105000,"email":"yuquan@webuy.ai","author":"yuquan","message":"feat: init"}]},"filePathRelative":"baguwen/vueyouhua.md"}');export{i as comp,r as data};
